# WebSocket 信令设计

## 1. 通信模型概览

协同编辑系统采用 WebSocket 全双工通信模型，客户端与服务端之间通过发送结构化 JSON 消息进行状态同步。典型信令包括：心跳、加入文档、操作同步、关键帧传输、用户上下线通知等。

客户端通过 `ClientMessage` 类型结构向服务端发送信令，服务端响应或广播 `ServiceMessage` 类型结构的数据。

---

## 2. 消息结构设计

### 2.1 通用字段结构

| 字段名       | 说明                       |
| ------------ | -------------------------- |
| `type`       | 消息类型（枚举定义）       |
| `timestamp`  | 客户端发出该消息的时间戳   |
| `documentId` | 所属文档 ID                |
| `userId`     | 当前用户 ID                |
| `sequence`   | 当前操作或文档快照序列号   |
| `data`       | 携带的业务负载（结构可变） |

> 所有消息均应具备这些字段，以便实现消息顺序控制与文档同步一致性。

---

## 3. 消息类型定义

### 3.1 客户端发送的命令（SendCommandType）

| 类型值        | 说明                                 |
| ------------- | ------------------------------------ |
| `heartbeat`   | 客户端心跳包，维持连接               |
| `join`        | 加入文档，会附带用户信息与原因       |
| `leave`       | 离开文档                             |
| `op`          | 文本操作（Delta diff）               |
| `key_frame`   | 主动发送关键帧（通常是文档初始内容） |
| `request_doc` | 请求服务端当前文档状态               |

### 3.2 服务端推送的命令（ReceiveCommandType）

| 类型值      | 说明                                   |
| ----------- | -------------------------------------- |
| `heartbeat` | 服务端心跳响应                         |
| `joined`    | 有新用户加入文档                       |
| `left`      | 有用户离开文档                         |
| `remote_op` | 来自其他用户的文本操作                 |
| `key_frame` | 关键帧数据（首次进入或断线重连时使用） |
| `user_list` | 当前在线用户列表                       |
| `rejected`  | 请求被拒绝（无权限、文档不存在等情况） |

---

## 4. 核心字段设计说明

### `sequence`

- 每个用户在发送操作（如 `op`、`key_frame`）时都会维护一个自增 `sequence`。
- 服务端在广播给其他用户时也会附带 `sequence`，用于保证接收方顺序正确执行。
- 在处理协同操作（OT）时是版本判断和冲突消解的关键。

### `timestamp`

- 标准化时间戳字段，用于排序、日志记录或延迟统计。
- 对操作精确顺序的判断建议仍以 `sequence` 为准。

---

## 5. 可拓展命令建议

预留以下信令类型供后续拓展使用：

| 类型值      | 建议用途               |
| ----------- | ---------------------- |
| `cursor`    | 光标位置同步           |
| `undo`      | 撤销操作               |
| `redo`      | 重做操作               |
| `presence`  | 用户 Presence 状态变更 |
| `comment`   | 评论或注释模块         |
| `selection` | 选区共享               |

---

## 6. 示例

### 客户端发送操作：

```json
{
  "type": "op",
  "timestamp": 1719320000000,
  "documentId": "doc-123",
  "userId": "user-abc",
  "sequence": 3,
  "data": {
    "delta": { "ops": [{ "retain": 5 }, { "insert": "A" }] }
  }
}
```

### 服务端推送远程操作：

```json
{
  "type": "remote_op",
  "timestamp": 1719320001200,
  "documentId": "doc-123",
  "userId": "user-def",
  "sequence": 3,
  "data": {
    "delta": { "ops": [{ "retain": 5 }, { "insert": "B" }] }
  }
}
```

---

## 7. 总结与最佳实践

- 推荐采用 **JSON 格式**，可读性强，扩展性好。
- 客户端应始终维护本地的 `sequence` 与 `userId`，并用于参与消息处理判断。
- 若接入更高性能场景，可引入 Protobuf 编码替代 JSON。
- 所有信令应具备良好的 **容错机制**，服务端广播失败不应导致状态紊乱。
- 推荐在服务端和客户端都加上 **日志记录与调试开关**，便于追踪协同流转。
